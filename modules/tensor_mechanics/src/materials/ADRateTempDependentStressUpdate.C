//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "ADRateTempDependentStressUpdate.h"

registerMooseObject("TensorMechanicsApp", ADRateTempDependentStressUpdate);

InputParameters
ADRateTempDependentStressUpdate::validParams()
{
  InputParameters params = ADRadialReturnStressUpdate::validParams();
  params.addClassDescription(
      "This class uses the stress update material in a radial return isotropic power law creep "
      "model. This class can be used in conjunction with other creep and plasticity materials "
      "for more complex simulations.");

  params.set<std::string>("effective_inelastic_strain_name") = "effective_plastic_strain";

  // Linear strain hardening parameters
  params.addCoupledVar("temperature", "Coupled temperature");
  params.addParam<Real>("start_time", 0.0, "Start time (if not zero)");

  // temperature dependent Young's modulus and Poisson's ratio
  params.addParam<std::vector<Real>>("Ex", "The temperature values");
  params.addParam<std::vector<Real>>("Ey", "The Young's modulus values");
  params.addParam<std::vector<Real>>("nux", "The temperature values");
  params.addParam<std::vector<Real>>("nuy", "The Poisson's ratio values");

  // Rate dependent plasticity parameters
  // Default values are from the paper by Michael E. Stender, et. al, 2018.
  // fluid parameters
  params.addParam<MaterialPropertyName>("theta_melt", 1700, "Melt temperature [K]");
  params.addParam<MaterialPropertyName>("mu_melt", 1.0e-6, "Melt viscosity [Pa*s]");
  params.addParam<MaterialPropertyName>("K_melt", 2.2e9, "Bulk modulus melt [Pa]");

  // solid parameters
  params.addParam<MaterialPropertyName>("Y0", 5.264e09, "Rate independent yield constant [Pa]");
  params.addParam<MaterialPropertyName>(
      "Y1", 2.688e05, "First rate independent yield temperature dependency [K]");
  params.addParam<MaterialPropertyName>(
      "Y2", 1.87e-03, "Second rate independent yield temperature dependency [1/K]");
  params.addParam<MaterialPropertyName>(
      "Y3", 8.683e02, "Third rate independent yield temperature dependency [K]");
  params.addParam<MaterialPropertyName>(
      "Y4", 3.316e01, "Fourth rate independent yield temperature dependency [-]");
  params.addParam<MaterialPropertyName>("Hmu", 0.01, "Isotropic hardening shear coefficient [-]");
  params.addParam<MaterialPropertyName>(
      "f1", 9.178e-02, "First flow rule coefficient constant [1/s]");
  params.addParam<MaterialPropertyName>("f2", 0.0, "Second flow rule coefficient constant [K]");
  params.addParam<MaterialPropertyName>("n1", 0.0, "Flow rule exponent constant [-]");
  params.addParam<MaterialPropertyName>(
      "n2", 5.699e03, "Flow rule exponent temperature dependence [K]");
  params.addParam<MaterialPropertyName>(
      "Rd1", 8.565e02, "Isotropic dynamic recovery constant [Pa]");
  params.addParam<MaterialPropertyName>(
      "Rd2", 5.419e03, "Isotropic dynamic recovery temperature dependence [K]");
  params.addParam<MaterialPropertyName>(
      "hxi", 1.670e-03, " Misorientation variable hardening constant [m/(s Pa)]");
  params.addParam<MaterialPropertyName>(
      "r", 1.0, " Misorientation variable hardening exponent, 0.5<=r<=1 [-]");

  return params;
}

ADRateTempDependentStressUpdate::ADRateTempDependentStressUpdate(const InputParameters & parameters)
  : ADRadialReturnStressUpdate(parameters),
    _temperature(isParamValid("temperature") ? &adCoupledValue("temperature") : nullptr),
    _start_time(getParam<Real>("start_time")),
    _theta_melt(getADMaterialProperty<Real>("theta_melt")),
    _mu_melt(getADMaterialProperty<Real>("mu_melt")),
    _K_melt(getADMaterialProperty<Real>("K_melt")),
    _Y0(getADMaterialProperty<Real>("Y0")),
    _Y1(getADMaterialProperty<Real>("Y1")),
    _Y2(getADMaterialProperty<Real>("Y2")),
    _Y3(getADMaterialProperty<Real>("Y3")),
    _Y4(getADMaterialProperty<Real>("Y4")),
    _Hmu(getADMaterialProperty<Real>("Hmu")),
    _f1(getADMaterialProperty<Real>("f1")),
    _f2(getADMaterialProperty<Real>("f2")),
    _n1(getADMaterialProperty<Real>("n1")),
    _n2(getADMaterialProperty<Real>("n2")),
    _Rd1(getADMaterialProperty<Real>("Rd1")),
    _Rd2(getADMaterialProperty<Real>("Rd2")),
    _hxi(getADMaterialProperty<Real>("hxi")),
    _r(getADMaterialProperty<Real>("r")),
    _hardening_variable(declareADProperty<Real>(_base_name + "hardening_variable")),
    _hardening_variable_old(getMaterialPropertyOld<Real>(_base_name + "hardening_variable")),
    _misorientation_variable(declareADProperty<Real>(_base_name + "misorientation_variable")),
    _misorientation_variable_old(
        getMaterialPropertyOld<Real>(_base_name + "misorientation_variable")),
    _plastic_strain(declareADProperty<RankTwoTensor>(_base_name + "plastic_strain")),
    _plastic_strain_old(getMaterialPropertyOld<RankTwoTensor>(_base_name + "plastic_strain"))
{
  // Get linear interpolation of Young's modulus and Poisson'ratio
  // The goal is to compute _shear_modulus_derivative
  // Todo: how to get ADMaterialProperty derivative w.r.t coupled variable
  std::vector<Real> Ex, Ey, nux, nuy;
  if (!(parameters.isParamValid("Ex") && parameters.isParamValid("Ey") &&
        parameters.isParamValid("nux") && parameters.isParamValid("nuy")))
    mooseError("Both 'x' and 'y' data must be specified for the Young's modulus and the Poisson's "
               "ratio. ");

  Ex = getParam<std::vector<Real>>("Ex");
  Ey = getParam<std::vector<Real>>("Ey");
  nux = getParam<std::vector<Real>>("nux");
  nuy = getParam<std::vector<Real>>("nuy");

  _data_youngs_modulus = libmesh_make_unique<LinearInterpolation>(Ex, Ey, false);
  _data_poissons_ratio = libmesh_make_unique<LinearInterpolation>(nux, nuy, false);
}

void
ADRateTempDependentStressUpdate::computeStressInitialize(const ADReal & effective_trial_stress,
                                                         const ADRankFourTensor & elasticity_tensor)
{
  _yield_stress = computeYieldStress();

  _shear_modulus = ElasticityTensorTools::getIsotropicShearModulus(elasticity_tensor);

  computeShearModulusDerivative(elasticity_tensor);

  _hardening_variable[_qp] = _hardening_variable_old[_qp];

  _misorientation_variable[_qp] = _misorientation_variable_old[_qp];

  updateInternalStateVariables(effective_trial_stress);
}

ADReal
ADRateTempDependentStressUpdate::computeResidual(const ADReal & effective_trial_stress,
                                                 const ADReal & scalar)
{
  computePlasticStrainRate(effective_trial_stress, scalar);

  ADReal p1 = _plastic_strain_rate * _dt;
  ADReal p2 =
      _C1 * _C2 * _hardening_variable[_qp] * _shear_modulus_derivative / _shear_modulus * _dt;

  ADReal tmp = p1 - scalar - p2;

  // Not sure what value to put here.
  // Choose 1e100 based on errors caused by dual number division around this magnitude
  if (tmp.value() > 1e100)
    mooseException("Residual out of bound..");

  return tmp;
}

ADReal
ADRateTempDependentStressUpdate::computeDerivative(const ADReal & effective_trial_stress,
                                                   const ADReal & scalar)
{
  computePlasticStrainRate(effective_trial_stress, scalar);

  if (std::isinf(_hardening_variable[_qp].value()))
    mooseException("Hardening variable out of bound..");

  ADReal theta = getTemperature();

  ADReal p1 = _C1 * (-3.0 * _shear_modulus / (_hardening_variable[_qp] + _yield_stress));
  ADReal p2 =
      _Hmu[_qp] * _shear_modulus * (1.0 + _misorientation_variable[_qp] / _hardening_variable[_qp]);
  ADReal p3 = _Rd1[_qp] * std::exp(-_Rd2[_qp] / theta) * _hardening_variable[_qp];
  ADReal derivative = p1 - _C1 * _C2 * (p2 - p3);

  ADReal tmp = derivative * _dt - 1.0;

  if (tmp.value() > 1e100)
    mooseException("Derivative out of bound..");

  return tmp;
}

void
ADRateTempDependentStressUpdate::computePlasticStrainRate(const ADReal & effective_trial_stress,
                                                          const ADReal & scalar)
{
  const ADReal theta = getTemperature();
  const ADReal stress_delta = effective_trial_stress - 3.0 * _shear_modulus * scalar;
  const ADReal ratio = stress_delta / (_hardening_variable[_qp] + _yield_stress);

  if (ratio > 1.0)
  {
    _plastic_strain_rate = _f1[_qp] * std::exp(-_f2[_qp] * theta) *
                           std::pow(std::sinh(ratio - 1.0), _n1[_qp] + _n2[_qp] / theta);
    _C1 = (_n1[_qp] + _n2[_qp] / theta) * _plastic_strain_rate / std::tanh(ratio - 1.0);
    _C2 = (3.0 * _shear_modulus * scalar - effective_trial_stress) /
          (_hardening_variable[_qp] + _yield_stress) / (_hardening_variable[_qp] + _yield_stress);
  }
  else
  {
    _plastic_strain_rate = 0.0;
    _C1 = 0.0;
    _C2 = 0.0;
  }

  // check value
  if (std::isinf(_plastic_strain_rate.value()) || std::isinf(_C1.value()) ||
      std::isinf(_C2.value()))
    mooseException(
        "Plastic strain variable out of bound.. check trial stress and reduce time step");
}

void
ADRateTempDependentStressUpdate::computeShearModulusDerivative(
    const ADRankFourTensor & elasticity_tensor)
{
  const ADReal theta = getTemperature();
  Real dE = _data_youngs_modulus->sampleDerivative(theta.value());
  Real dnu = _data_poissons_ratio->sampleDerivative(theta.value());

  ADReal poissons_ratio = ElasticityTensorTools::getIsotropicPoissonsRatio(elasticity_tensor);
  ADReal youngs_modulus = ElasticityTensorTools::getIsotropicYoungsModulus(elasticity_tensor);

  _shear_modulus_derivative = (2.0 * dE * (1.0 + poissons_ratio) - 2.0 * dnu * youngs_modulus) /
                              4.0 / (1.0 + poissons_ratio) / (1.0 + poissons_ratio);
}

void
ADRateTempDependentStressUpdate::initQpStatefulProperties()
{
  _plastic_strain[_qp].zero();

  _hardening_variable[_qp] = 1.0;

  _misorientation_variable[_qp] = 1.0;

  ADRadialReturnStressUpdate::initQpStatefulProperties();
}

void
ADRateTempDependentStressUpdate::propagateQpStatefulProperties()
{
  _hardening_variable[_qp] = _hardening_variable_old[_qp];

  _misorientation_variable[_qp] = _misorientation_variable_old[_qp];
  _plastic_strain[_qp] = _plastic_strain_old[_qp];

  ADRadialReturnStressUpdate::propagateQpStatefulPropertiesRadialReturn();
}

void
ADRateTempDependentStressUpdate::computeStressFinalize(
    const ADRankTwoTensor & plastic_strain_increment)
{
  _plastic_strain[_qp] = _plastic_strain_old[_qp] + plastic_strain_increment;
}

void
ADRateTempDependentStressUpdate::updateInternalStateVariables(const ADReal & effective_trial_stress,
                                                              const ADReal & scalar,
                                                              const ADReal & /*scalar_increment*/)
{
  const ADReal theta = getTemperature();

  /// Compute increment of isotropic harderning internal state variable
  ADReal hardening_variable_increment =
      _hardening_variable[_qp] * (_shear_modulus_derivative / _shear_modulus) +
      (_Hmu[_qp] * _shear_modulus *
           (1.0 + _misorientation_variable[_qp] / _hardening_variable[_qp]) -
       _Rd1[_qp] * std::exp(-_Rd2[_qp] / theta) * _hardening_variable[_qp]) *
          scalar;
  _hardening_variable[_qp] = _hardening_variable_old[_qp] + hardening_variable_increment;

  /// Compute increment of misorientation variable
  ADReal misorientation_variable_increment;
  const ADReal n_power = 1.0 - 1.0 / _r[_qp];
  if (n_power < libMesh::TOLERANCE)
    misorientation_variable_increment =
        _misorientation_variable[_qp] * (_shear_modulus_derivative / _shear_modulus) +
        _hxi[_qp] * _shear_modulus * std::abs(scalar);
  else
    misorientation_variable_increment =
        _misorientation_variable[_qp] * (_shear_modulus_derivative / _shear_modulus) +
        _hxi[_qp] * _shear_modulus *
            std::pow(_misorientation_variable[_qp] / _shear_modulus, n_power) * std::abs(scalar);
  _misorientation_variable[_qp] =
      _misorientation_variable_old[_qp] + misorientation_variable_increment;

  computePlasticStrainRate(effective_trial_stress, scalar);

  // check value
  if (std::isinf(_hardening_variable[_qp].value()))
    mooseException("Hardening variable out of bound.. reduce time step");
  if (std::isinf(_misorientation_variable[_qp].value()))
    mooseException("Misorientation variable out of bound.. reduce time step");
}

ADReal
ADRateTempDependentStressUpdate::computeYieldStress()
{
  const ADReal theta = getTemperature();

  ADReal nominator = 0.5 * _Y0[_qp] * (1.0 + std::tanh(_Y2[_qp] * (_Y3[_qp] - theta)));
  ADReal denominator = (_Y4[_qp] + std::exp(-_Y1[_qp] / theta));

  return nominator / denominator;
}

ADReal
ADRateTempDependentStressUpdate::getTemperature()
{
  return (*_temperature)[_qp];
}

Real
ADRateTempDependentStressUpdate::computeReferenceResidual(
    const ADReal & /*effective_trial_stress*/, const ADReal & scalar_effective_inelastic_strain)
{
  return scalar_effective_inelastic_strain.value();
}

bool
ADRateTempDependentStressUpdate::substeppingCapabilityEnabled()
{
  return getParam<bool>("use_substep");
}
